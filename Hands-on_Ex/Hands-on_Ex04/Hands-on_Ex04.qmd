---
title: "Hands-on Exercise 4"
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
date: "`r Sys.Date()`"
---

# Overview

In this exercise, we will focus on computing spatial weights using R. Some of the main learning objectives are:

-   importing geospatial data and csv file

-   compute spatial weights and calculating spatially lagged variables

# Data

| Data Set         | Description                                                                        |
|----------------|--------------------------------------------------------|
| `Hunan.shp`      | Hunan county boundary layer, geospatial data in ESRI shapefile format              |
| `Hunan_2012.csv` | Aspatial csv file containing selected Hunan's local development indicators in 2012 |

# Getting Started

The new package used in this exercise is `sdpep` . Use the appropriate functions in this package to compute spatial weights and calculate spatially lagged variables.

Ensure all the packages below are installed in your R environment!

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

# Importing the Data int R environment

Use st_read() in the sf package to import Hunan.shp. This imported shapefile will be simple features objects of sf.

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

Use read.csv() of readr package to import Hunan_2021.csv. The output is a R dataframe class.

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

## Performing relational join

In order to update the attribute table of hunan's SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe.

This is performed using left_join() of dplyr package.

```{r}
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
```

# Visualising Regional Development Indicator

Using qtm() of tmap package, we can prepare a basemap and a chloropleth map showing the distribution of GDPPC 2012.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

# Computing Contiguity Spatial Weights

In this section, we use poly2nb() of spdep package to compute contiguity weight matrices for the study area.

This function builds a neighbour list based on regions with contiguous boundaries. Contiguity refers to the concept of adjacency or proximity between spatial units, such as neighbouring regions or polygons. Understanding the relationship between neighbouring areas is crucial for various tasks.

## Computing (QUEEN) contiguity based neighbours

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

In this code chunk, "queen" argument is set to true. If you do not specify queen=FALSE, this function will return a list of first order neighbours using the Queen criteria.

The summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one neighbours.

We can use the function wm_q to list all neighbouring polygons of a specific polygon in our polygon object. For example, to see the neighbours for the first polygon in the object:

```{r}
wm_q[[1]]
```

From the output, we know that polygon 1 has 5 neighbours. The numbers prined are the polygon IDs as stored in hunan SpatialPolygonsDataFrame.

We can then retrive the county name of Polygon 1:

```{r}
hunan$County[1]
```

This reveals that polygon 1 is Anxiang county

To further understand its neighbours, we can retrieve the county names of the five neighbouring polygons:

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

We can also retrive the GDPPC of the five neighbouring countries:

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

Lastly, we can display the complete weight matrix by using str():

```{r}
str(wm_q)
```

## Creating (ROOK) contiguity based neighbours

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```
