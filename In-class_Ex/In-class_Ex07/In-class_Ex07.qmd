---
title: "In-Class Exercise 7"
execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"
---

```{r}
pacman::p_load(sp, spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

# Importing Data

```{r}
shan_sf <- st_read(dsn = "data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

This shapefile covers the entire Myanmar, so we need to filter out only the Shan region\
\
Check that it is in a sj object class

```{r}
shan_sf
```

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```

Shan region comprises of many subregions and districts (which we can observe if we inspect the full data). There are several variables as well, eg, total households.

## Data Preparation

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

We have to standardize the values (divide by total household and scale it up) to derive the ownership. Then, we rename it to make the field name more concise and easier to recognise.

We can create all the plots to plot the distribution of the newly derived variables. The code chunk below allows you to plot out all the variables in one view.

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

Left join the 2 dataframes with the unique identifier used to join both data objects is TS_PCODE. When we append all the ICT variables over, the first data file should be the geometry sf file, the second one will be the attribute data file. 'by' parameter defines the unique identifier, which is not necessary here since the unique identifier field has the same name, but it is good practice to define it.

If both files are a spatial file, we should use st_join() instead. Left join allows the use the sf for only one file.

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
  
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

# Correlation Analysis

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

## **Hierarchy Cluster Analysis**

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

### **Extracting clustering variables**

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

### **Data Standardisation**

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

The Z-score always equal to 1.

### **Visualising the standardised clustering variables**

Plot the graph to see the how the use of the different standardization affects.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

Using the distance metrics.

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

We can extract the clustering results and plot it into a dendrogram.

```{r}
plot(hclust_ward, cex = 0.6)
```

For example, if we put the cut-off at 200, we will have 2 clusters. To determine the cut-off, we should calculate the definite value.

We can do multiple calculations to see which one gives us the best results.

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(shan_ict, method = x)$ac
}

map_dbl(m, ac)
```

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

```{r}
fviz_gap_stat(gap_stat)
```

From her we can see that the closest optimisation difference is 5 and 6. 6 is slightly higher so we should choose 6.

Use rect.hclust() to clearly show the clusters so we can also see which cluster has the most amount of members.

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

Use as.factor() to convert it into a factor data type and arranged in a ordinal scale.

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

Use cbind() to append the 2 dataframes instead of left_join() because there are no unique identifers. However, if we perform any form of sorting, the sequence change and we cannot use cbind().

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

```{r}
qtm(shan_sf_cluster, "CLUSTER")
```

Since it is in the class factor, the numbers are all treated as individual classes. If it was in the numeric class, it would become a range.

Previously, poly2nb() only worked with sp objects, but the latest version does not require us to convert it to sp and we can just use the sf class.

```{r}
shan.nb <- poly2nb(shan_sf)
summary(shan.nb)
```

Since it is an sf object, we can use the plot() function to show the map.

```{r}
plot(st_geometry(shan_sf), border=grey(.5))
pts <- st_coordinates(st_centroid(shan_sf))
plot(shan.nb,
     pts,
     col="blue",
     add=TRUE)
```

![It is not enough to just identify the clusters, we should plot out the clusters to evaluate them.](images/clipboard-50334886.png)
