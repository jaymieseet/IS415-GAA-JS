{
  "hash": "b89c142ab8577a171d08b096d540b901",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 4\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\ndate: \"2024-03-05\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\jaymieseet\\IS415-GAA-JS\\In-class_Ex\\In-class_Ex04\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012)%>%\n  select(1:4, 7, 15)\n```\n:::\n\n\nwhen we left_join, it append everything from the hunan2012 to hunan. the select allow us to explicitly select the columns that we want. simeplfeatures have a geometric column, so if we inspect the hunan data now, we have 7 variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc <- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex04_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nqtm is a quick way to view our map data (plotting hunan and GDPPC), do not need to specify any classification methods. But a better way to plot a thematic map is to use all the tmap properties to define the style.\n\nThe plotting does not start until tm_polygons(). tm_text() is to add labelling on your map. tmap_arrange() allows us to put all the maps together in one whole view.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\n```\n:::\n\n\nwm_q is a list and this list indicates the neighbours of each polygon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThis shows the summary of the lists. even though the average number of links have a decimal place, the number of actual neighbours should be an integer, so we can round up or round down.\n\nThe top row of numbers is the number of neighbours and the bottom row is the number of geographical area. eg. there is only 1 geographical area with 11 neighbours.\n\nArea 30 and 65 have the least number of links. Area 85 have the most number of links.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  13.86   28.12   34.99   36.19   44.54   67.50 \n```\n:::\n:::\n\n\nreturns the neighbour list, based on their distance. Input is k1 coordinates.\n\nuse the largest distance to determine the cut off, always round up and not round down to not miss out any points.In this case, our cut-off distance will be 62.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 49 \nNumber of nonzero links: 226 \nPercentage nonzero weights: 9.412745 \nAverage number of links: 4.612245 \n2 regions with no links:\n1 21\n4 disjoint connected subgraphs\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex04_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n:::\n:::\n\n\nIn-class exercise\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr,GWmodel)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\jaymieseet\\IS415-GAA-JS\\In-class_Ex\\In-class_Ex04\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\nhunan <- left_join(hunan,hunan2012)%>%\n  select(1:4, 7, 15)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwn_d62 <- dnearneigh(coords,0,62, longlat = TRUE)\nhunan_sp <- hunan %>%\n  as_Spatial()\n```\n:::\n\n\nit is a complex data model and there is no geometric data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat <- gwss(data = hunan_sp,\n               vars = \"GDPPC\",\n               bw=6,\n               kernel = \"bisquare\",\n               adaptive = TRUE,\n               longlat = T)\n```\n:::\n\n\nbandwidth and adaptive have to match. if adaptive = TRUE, bw = 6 (neighbours), if it is false, bw will equal to 62 (kilometres)\n\nplot the map and try with fixed distance\n",
    "supporting": [
      "In-class_Ex04_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}