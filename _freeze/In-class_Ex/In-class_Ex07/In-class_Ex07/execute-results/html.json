{
  "hash": "b4b400c02db672adf88e1f0e31d3a92d",
  "result": {
    "markdown": "---\ntitle: \"In-Class Exercise 7\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\ndate: \"2024-03-05\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sp, spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n# Importing Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\jaymieseet\\IS415-GAA-JS\\In-class_Ex\\In-class_Ex07\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\nThis shapefile covers the entire Myanmar, so we need to filter out only the Shan region\\\n\\\nCheck that it is in a sj object class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 55 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n:::\n\n\nShan region comprises of many subregions and districts (which we can observe if we inspect the full data). There are several variables as well, eg, total households.\n\n## Data Preparation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n\nWe have to standardize the values (divide by total household and scale it up) to derive the ownership. Then, we rename it to make the field name more concise and easier to recognise.\n\nWe can create all the plots to plot the distribution of the newly derived variables. The code chunk below allows you to plot out all the variables in one view.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradio <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv <- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone <- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet <- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n:::\n\n\nLeft join the 2 dataframes with the unique identifier used to join both data objects is TS_PCODE. When we append all the ICT variables over, the first data file should be the geometry sf file, the second one will be the attribute data file. 'by' parameter defines the unique identifier, which is not necessary here since the unique identifier field has the same name, but it is good practice to define it.\n\nIf both files are a spatial file, we should use st_join() instead. Left join allows the use the sf for only one file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n:::\n\n\n# Correlation Analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## **Hierarchy Cluster Analysis**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\n### **Extracting clustering variables**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1  286.1852 554.1313   35.30618  260.6944    12.15939\n2  417.4647 505.1300   19.83584  162.3917    12.88190\n3  484.5215 260.5734   11.93591  120.2856     4.41465\n4  231.6499 541.7189   28.54454  249.4903    13.76255\n5  449.4903 708.6423   72.75255  392.6089    16.45042\n6  280.7624 611.6204   42.06478  408.7951    29.63160\n7  318.6118 535.8494   39.83270  214.8476    18.97032\n8  387.1017 630.0035   31.51366  320.5686    21.76677\n9  349.3359 547.9456   38.44960  323.0201    15.76465\n10 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\n### **Data Standardisation**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.z <- scale(shan_ict)\ndescribe(shan_ict.z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            vars  n mean sd median trimmed  mad   min  max range  skew kurtosis\nRADIO_PR       1 55    0  1  -0.04   -0.06 0.94 -1.85 2.55  4.40  0.48    -0.27\nTV_PR          2 55    0  1   0.05    0.04 0.78 -2.47 2.09  4.56 -0.38    -0.23\nLLPHONE_PR     3 55    0  1  -0.33   -0.15 0.68 -1.19 3.20  4.39  1.37     1.49\nMPHONE_PR      4 55    0  1  -0.05   -0.06 1.01 -1.58 2.40  3.98  0.48    -0.34\nCOMPUTER_PR    5 55    0  1  -0.26   -0.18 0.64 -1.03 3.31  4.34  1.80     2.96\n              se\nRADIO_PR    0.13\nTV_PR       0.13\nLLPHONE_PR  0.13\nMPHONE_PR   0.13\nCOMPUTER_PR 0.13\n```\n:::\n:::\n\n\nThe Z-score always equal to 1.\n\n### **Visualising the standardised clustering variables**\n\nPlot the graph to see the how the use of the different standardization affects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = 'euclidean')\n```\n:::\n\n\nUsing the distance metrics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n```\n:::\n\n\nWe can extract the clustering results and plot it into a dendrogram.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nFor example, if we put the cut-off at 200, we will have 2 clusters. To determine the cut-off, we should calculate the definite value.\n\nWe can do multiple calculations to see which one gives us the best results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(shan_ict, method = x)$ac\n}\n\nmap_dbl(m, ac)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  average    single  complete      ward \n0.8131144 0.6628705 0.8950702 0.9427730 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12345)\ngap_stat <- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = shan_ict, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 1\n          logW   E.logW       gap     SE.sim\n [1,] 8.407129 8.680794 0.2736651 0.04460994\n [2,] 8.130029 8.350712 0.2206824 0.03880130\n [3,] 7.992265 8.202550 0.2102844 0.03362652\n [4,] 7.862224 8.080655 0.2184311 0.03784781\n [5,] 7.756461 7.978022 0.2215615 0.03897071\n [6,] 7.665594 7.887777 0.2221833 0.03973087\n [7,] 7.590919 7.806333 0.2154145 0.04054939\n [8,] 7.526680 7.731619 0.2049390 0.04198644\n [9,] 7.458024 7.660795 0.2027705 0.04421874\n[10,] 7.377412 7.593858 0.2164465 0.04540947\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_gap_stat(gap_stat)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nFrom her we can see that the closest optimisation difference is 5 and 6. 6 is slightly higher so we should choose 6.\n\nUse rect.hclust() to clearly show the clusters so we can also see which cluster has the most amount of members.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nUse as.factor() to convert it into a factor data type and arranged in a ordinal scale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(hclust_ward, k=6))\n```\n:::\n\n\nUse cbind() to append the 2 dataframes instead of left_join() because there are no unique identifers. However, if we perform any form of sorting, the sequence change and we cannot use cbind().\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nSince it is in the class factor, the numbers are all treated as individual classes. If it was in the numeric class, it would become a range.\n\nPreviously, poly2nb() only worked with sp objects, but the latest version does not require us to convert it to sp and we can just use the sf class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sf)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n:::\n:::\n\n\nSince it is an sf object, we can use the plot() function to show the map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), border=grey(.5))\npts <- st_coordinates(st_centroid(shan_sf))\nplot(shan.nb,\n     pts,\n     col=\"blue\",\n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n![It is not enough to just identify the clusters, we should plot out the clusters to evaluate them.](images/clipboard-50334886.png)\n",
    "supporting": [
      "In-class_Ex07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}